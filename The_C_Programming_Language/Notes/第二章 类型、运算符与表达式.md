# 类型、运算符与表达式

变量和常量是程序处理的两种基本数据对象。声明语句说明变量的名字及类型，也可以指定变量的初值。运算符指定将要进行的操作。表达式则把变量与常量组合起来生产新值。对象的类型决定该对象可取值的集合以及可以对该对象执行的操作。

ANSI标准对语言的基本类型与表达式做了许多小的修改与增补。所有整型都包括signed（带符号）和unsigned（无符号）两种形式，且可以表示无符号常量与十六进制字符常量。浮点运算可以单精度进行，还可以使用更高精度的long double类型运算。字符串常量可以在编译时连接。ANSIC还支持枚举类型。对象可以声明为const（常量）类型，表明其值不能修改。该标准还对算术类型之间的自动强制转换规则进行了扩充，以适合于更多的数据类型。

## 1、变量名

变量名是由字母和数字组成的序列，但其中第一个字符必须为字母。下划线“_”被看成是字母，通常用于命名较长的变量名，以提高其可读性。由于例程的名字通常以下划线开头，因此变量名不要以下划线开头。大小写敏感，在传统C语言中，变量名使用小写字母，符号常量名全部使用大写字母。

类似于if、else、int、float等关键字是保留给语言本身使用的，不能把它们用作变量名。所有关键字中的字符都必须小写。

选择的变量名要能够尽量从字面上表达变量的用途，这样做不容易引起混淆。局部变量一般使用较短的变量名（尤其是循环控制变量），外部变量使用较长的名字。

## 2、数据类型及长度

C语言只提供了下列几种基本数据类型：

|类型|解释|
|---|---|
|char|字符型，占用一个字节，可以存放本地字符集中的一个字符|
|int|整型，通常反映了所用机器中整数的最自然长度|
|float|单精度浮点型|
|double|双精度浮点型|

此外，还可以在这些基本数据类型的前面加上一些限定符。short与long两个限定符用于限定整型：

> short int sh;  
> long int counter;

关键字int可以省略。

int通常代表特定机器中整数的自然长度。short类型通常为16位，long类型通常位32位，int类型可以为16位或32位。各编译器可以根据硬件特性自主选择合适的类型长度，但要遵循下列限制：short与int类型至少位16位，而long类型至少位32位，并且short类型不得长于int类型，而int类型不得长于long类型。

类型限定符signed与unsigned可用于限定char类型或任何整型。unsigned类型的数总是正值或0，并遵守算术模$2^n$定律，其中n是该类型占用的位数。例如，占用8位的unsigned char类型变量的取值范围为0~255，而signed char类型变量的取值范围为-128~127（在采用对二补码的机器上）。

long double类型表示高精度的浮点数。同整型一样，浮点型的长度也取决于具体的实现。

有关这些类型长度定义的符号常量以及其它与机器和编译器有关的属性可以在标准头文件<limits.h>与<float.h>中找到。

## 3、常量

类似于1234的整数常量属于int类型。long类型的常量以字母l或L结尾，如123456789L。如果一个整数太大以至于无法用int表示，也将被当作long类型处理。无符号常量以字母u或U结尾。后缀ul或UL表明是unsigned long类型。

浮点数常量中包含一个小数点（如123.4）或一个指数（如le-2），也可以两者都有。没有后缀的浮点数常量为double类型。后缀f或F表示float类型，而后缀l或L则表示long double类型。

整型数还可以用八进制或十六进制表示。带前缀0的整型常量表示它为八进制形式；前缀为0x或0X，则表示它为十六进制形式。例如，十进制数31可以写成八进制形式037，也可以写成十六进制形式0x1f或0X1F。八进制与十六进制的常量也可以使用后缀L表示long类型，使用后缀U表示unsigned类型。例如，0XFUL是一个unsign long类型（无符号长整型）的常量，其值等于十进制15。

一个字符常量是一个整数，书写时将一个字符括在单引号中，如'x'。字符在机器字符集中的数值就是字符常量的值。例如，在ASCII字符集中，字符'0'的值为48，它与数值0没有关系。如果用字符'0'代替这个与具体字符集有关的值（比如48），程序就无需关心该字符对应的具体值，增加了程序的易读性。字符常量一般用来与其它字符进行比较，但也可以像其它整数一样参与数值运算。

某些字符可以通过转义字符序列（例如，换行符\n）表示为字符和字符串常量。转义字符只表示一个字符。可以用`'\ooo'`表示任意的字节大小的位模式。其中，ooo代表1~3个八进制数字（0...7）。这种位模式还可以用`'\xhh'`表示，其中，hh是一个或多个十六进制数字（0...9,a...f,A...F）。我们可以按照下列形式书写语句：

```C
#define VTAB '\013'     /*ASCII vertical tab*/
#define BELL '\007'     /*ASCII bell character*/
```

也可以用十六进制的形式书写：

```C
#define VTAB '\xb'     /*ASCII vertical tab*/
#define BELL '\x7'     /*ASCII bell character*/
```

字符常量'\0'表示值为0的字符，也就是空字符（null）。我们通常用'\0'的形式代替0，以强调某些表达式的字符属性，但其数字值为0。

常量表达式是仅仅包含常量的表达式。这种表达式在编译时求值，可以出现在常量可以出现的任何位置。

```C
#define MAXLINE 1000
char line[MAXLINE+1];
```

字符串常量也叫字符串字面值，是用双引号括起来的0个或多个字符组成的字符序列。例如：

> "I am a string"

或

> ""  /\*空字符串\*/

都是字符串。双引号不是字符串的一部分，只用于限定字符串。转义字符同样也可以用在字符串中，使用`\"`表示双引号字符。编译时可以将多个字符串常量连接起来。例如：

> "hello," " world"

等价于

> "hello, world"

字符串常量的连接支持较长的字符串分散在若干个源文件中。

从技术角度看，字符串常量就是字符数组。字符串内部表示使用一个空字符`'\0'`作为字符串的结尾，因此，存储字符串的物理存储单元数比括在双引号中的字符多一个。C语言对字符串的长度没有限制，但程序必须扫描完整个字符串后才能确定字符串的长度。标准库函数strlen(s)可以返回字符串参数s的长度，但不包括末尾的'\0'。

```C
/*strlen: return length of s*/
int strlen(char s[])
{
    int i;

    while(s[i] != '\0')
        ++i;
    return i;
}
```

'x'与"x"是不同的，前者是一个整数，其值是字母x在机器字符集中对应的数值（内部表示值）；后者是包含一个字符以及一个结束符'\0'的字符数组。

枚举常量是另外一种类型的常量。枚举是一个常量整型值的列表，例如：

> enum boolean { NO, YES};

在没有显示说明的情况下，enum类型中第一个枚举名的值为0.第二个为1，依此类推。如果只指定了部分枚举名的值，那么未指定值的枚举名的值将依着最后一个指定值向后递增。

不同枚举中的名字必须互不相同。同意枚举中不同的名字可以具有相同的值。

相对于`#define`语句来说，它的优势在于常量值可以自动生成。尽管可以声明enum类型的变量，但编译器不检查这种类型的变量中存储的值是否为该枚举的有效值。不过，枚举变量提供这种检查，因此更具优势。此外，调试程序可以以符号形式打印出枚举变量的值。

## 4、声明

所有变量都必须先声明后使用，尽管某些变量可以通过上下文隐式地声明。一个声明指定一种变量类型，后面所带的变量表可以包含一个或多个该类型的变量。

> int lower, upper, step;  
> char c, line[1000];

一个声明语句中的多个变量可以拆开在多个声明语句，这种书写形式需占用较多的空间，但便于向各声明语句中添加注释，也便于以后修改。

还可以在声明的同时对变量进行初始化。如：

> float eps = 1.0e-5;

如果变量不是自动变量,则只能进行一次初始化操作，概念上讲，应该是在程序开始执行之前进行，并且初始化表达式必须为常量表达式。每次进入函数或程序块时，显式初始化的自动变量都将被初始化一次，其初始化表达式可以是任何表达式。默认情况下，外部变量与静态变量将被初始化为0。未经显式初始化的自动变量的值为未定义值（即无效值）。

任何变量的声明都可以使用const限定符限定。该限定符指定变量的值不能被修改。对数组而言，const限定符指定数组所有元素的值都不能修改。也可配合数组参数使用，它表明函数不能修改数组元素的值。如果试图修改const限定的值，其结果取决于具体的实现。

## 5、运算符

二元运算符包括：+、-、*、/、%（取模）。整数除法会截断结果中的小数部分。

判断闰年:

```C
if((year % 4 ==0 && year % 100 != 0) || year % 400 == 0)
    printf("%d is a leap year\n", year);
else
    printf("%d is not a leap year\n", year);
```

取模运算不能应用于float或double类型。在有负操作数的情况下，整数除法截取的方向以及取模运算结果的符号取决于具体机器的实现，这和处理上溢或下溢的情况是一样的。

## 6、关系运算符与逻辑运算符

关系运算符包括：>、>=、<、<=。

逻辑运算符&&与||有一些较为特殊的属性，由&&与||连接的表达式按从左到右的顺序进行求值，且在知道结果值为真或假后立即停止计算。

```C
for(i=0; i<lim-1 && (c=getchar()) != '\n' && c != EOF; ++1)
    s[i] = c;
```

如果`i<lim-1`为假，就没有必要读入下一字符。

根据定义，在关系表达式或逻辑表达式中，如果关系为真，则表达式的结果值为1；如果为假，则为0。

逻辑非运算符`!`的作用是将非0操作数转换为0，将操作数转换为1。

## 7、类型转换

一般来说，自动转换是指把“比较窄的”操作数转换为“比较宽的”操作数，并且不丢失信息的转换。反之，编译器可能会给出警告信息。

C语言没有指定char类型的变量是signed还是unsigned。当把一个char类型的值转换为int时，不同的机器可能产生不同的结果。

C语言的定义保证了机器的标注打印字符集中的字符不会是负值，因此，在表达式中这些字符总是正值。但存储在字符变量中的位模式不同的机器可能正负值不同。为了保证程序的可移植性，如果要在char类型的变量中存储非字符数据，最好指定signed还是unsigned限定符。

某些函数（比如isdigit）在结果为真时可能返回任意的非0值。在if、while、for等语句的测试部分中，“真”就意味着“非0”，两者没有区别。

C中，很多情况下会进行隐式的算术类型转换。一般来说，如果二元运算符的两个操作数具有不同的类型，那么在进行运算之前先把“较低”类型提升为“较高”类型，运算的结果为较高的类型。

注意，表达式中float类型的操作数不会自动转换为double类型。一般来说，数学函数（如标准头文件<math.h>中定义的函数）使用双精度类型的变量。使用float类型主要是为了在使用较大的数组时节省存储空间，有时也为了节省机器执行时间。

当表达式中包含unsigned类型的操作数时，转换规则要复杂一些。因为带符号值与无符号值之间的比较运算是与机器相关，取决于机器中不同整数类型的大小。

赋值时也要进行类型转换。复制运算符右边的值需要转换为左边变量的类型，左边变量的类型即赋值表达式结果的类型。

无论是否进行符号扩展，字符型变量都将被转换为整型变量。

当把较长的整数转换为较短的整数或char类型时，超出的高位部分将被丢弃。

当把float类型转换为int类型，小数部分将被截取掉；当把double类型转换为float类型时，是四舍五入还是截取看具体实现。

由于函数调用的参数是表达式，所以在把参数传递给函数时也可能进行转换。在没有函数原型的情况下，char与short类型都将被转换为int类型，float类型将被转换为double类型。因此，即使调用函数的参数为char或float类型，我们也把函数参数声明为int或double类型。

最后，在任何表达式中都可以使用强制类型转换进行显示类型转换。

> （类型名）表达式

在上述语句中，表达式首先被赋值给类型名指定的类型的某个变量，然后再用该变量替换上述整条语句。强制类型转换只是生成一个指定类型的n的值，n的值并没有改变。

通常情况下，参数是通过函数原型声明的。当函数被调用时，声明将对参数进行自动强制转换。

## 8、自增运算符与自减运算符

C提供了两个用于变量递增与递减的特殊运算符：`++`和`--`。前者使操作数递减1，后者使操作数递减1。

```C
if(c = '\n')
    ++n1;
```

自增和自减运算符在做前缀时，表达式先将操作数进行递增或递减，然后使用表达式的值，反之，则先使用表达式的值，再将操作数递增或递减。

自增和自减运算符只能作用于变量，类似于`(i+j)++`是非法的。

```C
/*squeeze: delete all c from s*/
void squeeze(char s[], int c)
{
    int i, j;

    for(i = j = 0; s[i] != '\0'; i++)
        if(s[j] != c)
            s[j++] = s[i];
    s[j] = '\0';
}
```

```C
/*strcat: concatenate t to end of s; s must be big enough*/
void strcat(char s[], char t[])
{
    int i, j;

    i = j = 0;
    while(s[i] != '\0') /*find end of s*/
        i++;
    while((s[i++] = t[j++]) != '\0')    /*copy t*/
}
```

## 9、换位运算符

C提供了6个位操作运算符。这些运算符只能作用于整型操作数，包括signed和unsign。

|位运算符|涵义|
|---|---|
| & |按位于（AND）|
| \| |按位或（OR）|
| ^ |按位异或（X0R）|
| <<n |左移n位|
| >>n |右移n位|
| ~ |按位求反|

按位与运算符&经常用于屏蔽某些二进制位，例如：
> n = n & 0177;

该语句将n中除7个低二进制位外的其它位置均置为0。

按位或运算符|常用于将某些二进制位置为1，例如：
> x = x | SET_ON;

该语句将x中对应于SET_ON中为1的那些二进制位置为1。

按位异或运算符^当两个操作数的对应位不相同时将该位设置为1，否则设为0。

移位运算符分别用于将运算的左操作数左移和右移，移动的位数由右操作数指定（必须为非负值）。在对unsigned类型的值进行右移时，左边补0；当对signed类型的值进行右移时，算术移位（即左边空出的部分用符号位填补）或逻辑移位（补0）取决于机器的实现。

一元运算符~用于求整数的二进制反码，即分别将操作数各二进制位上的1变为0，0变成1。例如：
> x =x & ~077

将把x的最后6位设置位0，并且与机器字长无关，可以移植。它比形式为`x&0177700`的表达式要好，因为后者假定x是16位的数值。~077是常量表达式，可以在编译时求值，所以并没有增加额外开销。

```C
/*getbits: get n bits from positon p*/
unsigned getbits(unsigned x, int p, int n)
{
    return (x >> (p+1-n)) & ~(~0 << n);
}
```

其中，表达式`x<<(p+1-n)`将期望获得的字段移位到字的最右端。~0的所有位都为1，这里使用语句`~0<<n`将~0左移n位，并将最右边的n位补零。在使用~运算对它按位取反，建立最右边n位全为1的屏蔽码。

## 10、赋值运算符与表达式

大多数二元运算符都有一个相应的赋值运算`op=`，其中op可以是下面这些运算符之一：
> \+、 \-、 *、 /、 %、 <<、 >>、 &、 ^、 |

若表达式expr1和表达式expr2：
> expr1 op= expr2

等价于：
> expr1 = (expr1) op (expr2)

它们的区别在于，前者只计算一次。

```C
/*bitcount: count 1 bits in x*/
int bitcount(unsigned x)
{
    int b;

    for(b = 0; x != 0; x >>= 1)
        if(x & 01)
         b++;
    return b;
}
```

赋值运算符除了简洁外，表示方式与人的思维习惯比较接近。我们通常会说“把2加到i上”或“把i+2”,而不会说"取i的值，加上2， 再把结果放回到i中"。另外，对于复杂的表达式，赋值运算符使程序代码更易于理解，并且，它还有助于编译器产生高效的代码。

## 11、条件表达式

表达式：
> expr1 ? expr2 : expr3

中，首先计算expr1，如果其值不等于0（为真），则计算expr2的值，并以该值作为条件表达式的值，否则，将对expr3进行同样的操作。

采用条件表达式可以编写出很简洁的代码。通常对expr1加上圆括号便于阅读。

```C
for(i + 0; i < n; i++)
    printf("%6d%c", a[i], (i%10==9 || i==n-1) ? '\n' : ' ');
```

比用等价的if-else结构编写的代码要紧凑一些。

## 12、运算符优先级与求值次序

C没有指定同一运算符中多个操作数的计算顺序（&&、||、?:和,运算符除外）。例如：
> x = f() + g();

中，f()和g()的计算顺序是不确定的。因此，如果函数f或g改变了另一个函数所使用的变量，x的结果就不确定了。为了保证特定的计算顺序，可以把中间结果保存在临时变量中。

类似的，C也没有指定函数各参数的求值顺序。因此，下列语句
> printf("%d %d\n", ++n, power(2,n)); /\*wrong\*/

不同的编译器可能会产生不同的结果。

函数调用、嵌套赋值语句、自增与自减运算符都有可能产生“副作用”——在对表达式求值的同时，修改了某些变量的值。
